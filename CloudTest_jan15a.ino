/*
This code is wirtten by:
s214405 - Simon Voss
s205937 - Sigurd Bernstein
s214412 - Matthias Winther
s214398 - Emil Pedersen
s214426 - Lukas Falk Nyholm
s214419 - Thomas Holst
For the cource 34338 Telecommunication programming projects with Arduino Jan 24
Date 18 Jan 2024

The code is spesific for the ESP8266 Node 0.9 MCU , pin numbers and other inputs functions might have to be changed for other microcontrollers


Sketch generated by the Arduino IoT Cloud Thing "Untitled"
https://create.arduino.cc/cloud/things/0e7d4fee-a6dc-47f7-9147-0a1afd613ebd 

Arduino IoT Cloud Variables description

The following variables are automatically generated and updated when changes are made to the Thing

String homeStatusMsg;
float temperatureSensor;
bool lukasAccess;
bool matthiasAccess;
bool switchLED;

Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
which are called when their values are changed from the Dashboard.
These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

#include <Bonezegei_DHT11.h>  // Download: Bonezegei_DHT11 by - Bonezegei (JofelBatutay)
#include <SPI.h>
#include <MFRC522.h>  // Download: MFRC522 by - GithubCommunity
#include "Servo.h"    // Download: Servo by - Michael Margolis, Arduino

//GPIO pins used
#define servoPin 0
#define RST_PIN 4  // Configurable, see typical pin layout above
#define SS_PIN 15  // Configurable, see typical pin layout above
#define TempHum_Pin 2
#define Fan_Pin 3

//////////////////// Variables - Calls ///////////////////

//Temp sensor
float Celcius = 0;
Bonezegei_DHT11 dht(TempHum_Pin);


//RFID
MFRC522 rfid(SS_PIN, RST_PIN);  // Instance of the class
MFRC522::MIFARE_Key key;
Servo myservo;
byte nuidPICC[4];  // Init array for NUID
String previousId = ""; // init String for same id check
int idMatch = 0; // init int that allows the same user to log in and out


struct ID {
  float Temp;       // Temperature in celcius
  int Light[3];     // How the light is to be
  String id;        // ID of the card
  char Name[10];    // Name of the card holder
  bool homeStatus;  // Whether or not a user is home
  bool access;      // User's access permission
};

ID DEF{25, 
      {0,0,0}, 
      "00000000", 
      "Default", 
      true, 
      true};
ID Lukas = {23.5, 
          {255,255,255}, 
          "649ae7b", 
          "Lukas", 
          false, 
          false};
ID Matthias = {23.5, 
              {0,255,0}, 
              "24d0dc52", 
              "Matthias", 
              false, 
              false};
//ID Emil = {23.5, {255,0,255}, "92225cce", "Emil", false, false};
//ID Sigurd = {23.5, {255,255,0}, "743ce552", "Sigurd", false, false};
//ID Simon = {23.5, {255,0,0}, "3063ed22", "Simon", false, false};
//ID Thomas = {23.5, {255,255,255}, "c42edc52", "Thomas", false, false};
ID Current = DEF;
struct ID users[] = {Emil, Lukas, Matthias, Sigurd, Simon, Thomas};

// Color intensity
int R_old = 255;
int G_old = 255;
int B_old = 255;
// light level condition
bool dark = false;
// Instantiate RGB LED colors. All set to the same pin, due to having only a single LED
static int RLED = 5;
static int GLED = 5;
static int BLED = 5;

//Fan
int Fan_PWM = 0;       //Fan speed between 0 and 255
int Fan_Speed = 0;     //Fan speed percentage %
float Desired = 23.5;  //Temp variable

//////////////// RFID and door functions ////////////////////

void RFID() {

  // Reset the loop if no new card present on the sensor/reader.
  if (!rfid.PICC_IsNewCardPresent())
    return;

  // Verify if the NUID has been read
  if (!rfid.PICC_ReadCardSerial())
    return;


  // Check is the PICC of Classic MIFARE type. This ensuresthe user is informed if the id is too complex to read.
  if (piccType != MFRC522::PICC_TYPE_MIFARE_MINI && piccType != MFRC522::PICC_TYPE_MIFARE_1K && piccType != MFRC522::PICC_TYPE_MIFARE_4K) {
    Serial.println(F("Your tag is not of type MIFARE Classic."));
    return;
  }

  // Store NUID into the array
  for (byte i = 0; i < 4; i++) {
    nuidPICC[i] = rfid.uid.uidByte[i];
  }

  delay(0); // works as yield

  String id = hex2String(rfid.uid.uidByte, rfid.uid.size); // Saves the id as a string

  // Check if the id matches the previous id if yes then it increasesd the match value. otherwise set the id to the previous and reset match
  if (id.equals(previousId)) {
    idMatch += 1;
  } else {
    previousId = id;
    idMatch = 0;
  }

  Serial.print(F("ID tag: ")); // print the tag id
  printHex(rfid.uid.uidByte, rfid.uid.size);
  Serial.println();

  bool isTrue = checkId(id); // if id matches the id's listed isTrue = true

  doorLock(id, isTrue, idMatch); // controls the servo

  // Halt PICC
  rfid.PICC_HaltA();

  // Stop encryption on PCD
  rfid.PCD_StopCrypto1();
}



void printHex(byte *buffer, byte bufferSize) {
  // prints the hex id
  for (byte i = 0; i < bufferSize; i++) {
    Serial.print(buffer[i] < 0x10 ? " 0" : " ");
    Serial.print(buffer[i], HEX);
  }
}

String hex2String(byte *buffer, byte bufferSize) {
  // return the hex id as a string
  String userid;
  for (byte i = 0; i < rfid.uid.size; i++) {
    userid += String(rfid.uid.uidByte[i], HEX);
  }
  return userid;
}

bool checkId(String id) {
  // Checks if id is in whitelist
  // Serial.println("id:" + id);
  bool isTrue = false;
  String whitelist[6] = { "", "", "", "", "", "" }; // creates empty whitelist
  
    /*
  Here we set the room to be the desired temperature and lights,
  if the user checking in has access.
  */
  if (Lukas.access == true) {
    whitelist[0] = Lukas.id;
    if (id.equals(Lukas.id)) {
      Desired = Lukas.Temp;
      Current = Lukas;
      Lukas.homeStatus=true;
    }
  } else {
    whitelist[0] = "";
  }
  if (Matthias.access == true) {
    whitelist[1] = Matthias.id;
    if (id.equals(Matthias.id)) {
      Desired = Matthias.Temp;
      Current = Matthias;
      Matthias.homeStatus=true;
    }
  } else {
    whitelist[1] = "";
  }
  if (Lukas.access == true) {
    if (id.equals(Lukas.id)) {
      whitelist[2] = Lukas.id;
      Desired = Lukas.Temp;
      Current = Lukas;
      Lukas.homeStatus=true;
    }
  } else {
    whitelist[2] = "";
  }

  // sets isTrue on comparison.
  for (int i = 0; i < 6; i++) {
    if (id.equals(whitelist[i])) {
      isTrue = true;
      break;
    } else {
      isTrue = false;
    }
  }
  // print access
  if (isTrue == true) {
    Serial.println("Access Granted!");
  } else {
    Serial.println("Access Denied!");
  }
  return isTrue;
}

void doorLock(String id, bool isTrue, int idMatch) {
  // checks isTrue and takes modulus of Match to determine if the door can open 
  // and if the user wants to log in or out based on the value returned from modulus 
  Serial.println(idMatch);
  if (isTrue == true) {
    if (idMatch % 2 == 1) {
      myservo.write(0); //closes door
      Current = DEF; // sets current user to default
      dark = false; // turns lights off
      Lukas.homeStatus = false;
      Matthias.homeStatus = false;
      Emil.homeStatus = false;
      Sigurd.homeStatus = false;
      Simon.homeStatus = false;
      Thomas.homeStatus = false;
      //Lights(Current);
    } else {
      myservo.write(90); //opens door
      checkLight();
    }
  } else {
    myservo.write(0);
    Current = DEF;
    dark = false;
    Lukas.homeStatus = false;
    Matthias.homeStatus = false;
    Emil.homeStatus = false;
    Sigurd.homeStatus = false;
    Simon.homeStatus = false;
    Thomas.homeStatus = false;
  }
}

///////////////// CLimate Functions ///////////////

void TempHumModule() {

  // Check if the specified interval has elapsed

  if (dht.getData()) {               // get All data from DHT11
    Celcius = dht.getTemperature();  // return temperature in celsius
  }
}

void FanControl() {
  /*
  All the 256 possible values for analog output pins,
  will be mapped to 0 to 100, to represent them as percentages.
  This gets written to the fan's pin.
  */
  Fan_PWM = map(Fan_Speed, 0, 100, 0, 255);
  analogWrite(Fan_Pin, Fan_PWM);
}

void ClimateControl(float Desired) {
  /*
  Function for controlling the fan, based on temperature.
  ClimateControl() calls the functions TempHumModule() and FanControl().
  */
  TempHumModule();  //This function should be called every loop

  // When it's warmer than we want it to be,
  // it turns on the fan
  if (Celcius > Desired) {
    Fan_Speed = 100;
  } else {
    Fan_Speed = 0;
  }
/*
  if (Celcius - Desired > 5) {                                   //Temp diference in celcius
    Fan_Speed = 100;                                             //Input in percentage
  } else if (Celcius - Desired > 3) {                            //Temp diference in celcius
    Fan_Speed = 80;                                              //Input in percentage
  } else if (Celcius - Desired > 2) {                            //Temp diference in celcius
    Fan_Speed = 60;                                              //Input in percentage
  } else if (1 < Celcius - Desired && Celcius - Desired <= 2) {  //Temp diference in celcius
    Fan_Speed = 40;                                              //Input in percentage
  } else if (1 <= Celcius - Desired) {                           //Temp diference in celcius
    Fan_Speed = 0;                                               //Input in percentage
  }
*/
  delay(0);
  FanControl();  //Function that sends out a PWM signal to the MOSFET
}


void climateInfo() {
  /*
  Prints fan speed and temperature to serial monitor
  */
  Serial.print("Fan strength is at: ");
  Serial.print(Fan_Speed);
  Serial.print(", Celcius: ");
  Serial.print(Celcius);
}


///////////// Light functions //////////////////

void checkLight() {
  // Checks light levels
  if (lightSensor() < 4) {
    dark = true;
  } else {
    dark = false;
  }
}

void Lights(struct ID name) {
  /*
  Function to control the lights.
  When it' dark, the lights turns on.
  Otherwise the lights are off.
  */
  
  //Serial.println("Lights - check");
  //The light is activated if the sensor detects
  /*if (dark) {
    setLight(name);
  } else if (name.id == DEF.id) {
    setLight(name);
  }*/
  checkLight();
  Serial.println(dark);
  if(dark) {
    analogWrite(RLED, 255);
    analogWrite(GLED, 255);
    analogWrite(BLED, 255);
    switchLED = true;
  } else if(!dark) {
    analogWrite(RLED, 0);
    analogWrite(GLED, 0);
    analogWrite(BLED, 0);
    switchLED = false;
  }
}

float lightSensor() {
  // Reads the photoresistor
  // This function converts value of the analog pin to a number between 0 and 100
  float light_digital = analogRead(A0);
  float light = 100 * light_digital / 1023;
  Serial.println(light);
  return light;
}

/*
void setLight(struct ID name) {
  // Function to gradually change the light intensity
  // for R, G and B in the LED.
  
  if ((R_old != name.Light[0]) || (G_old != name.Light[1]) || (B_old != name.Light[2])) {
    // if statements are run to check each value to make sure it matches if not then 1 is either added or subtracted
    if (R_old > name.Light[0]) {
      R_old -= 1;
    } else if (R_old < name.Light[0]) {
      R_old += 1;
    }
    if (G_old > name.Light[1]) {
      G_old -= 1;
    } else if (G_old < name.Light[1]) {
      G_old += 1;
    }
    if (B_old > name.Light[2]) {
      B_old -= 1;
    } else if (B_old < name.Light[2]) {
      B_old += 1;
    }
    // lastly the colors are defined
    analogWrite(RLED, R_old);
    analogWrite(GLED, G_old);
    analogWrite(BLED, B_old);
  }
}
*/

void setHomeStatusMsg(){
  if(Lukas.homeStatus && Matthias.homeStatus) {
    homeStatusMsg = "Lukas and Matthias are home!";
  } else if (Lukas.homeStatus) {
    homeStatusMsg = "Lukas is home!";
  } else if (Matthias.homeStatus) {
    homeStatusMsg = "Matthias is home!";
  } else {
    homeStatusMsg = "Nobody is home.";
  }
}

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(115200);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);
  
  
  
  pinMode(TempHum_Pin, INPUT);
  dht.begin();  //Libary initialicer


  //Lights
  pinMode(RLED, OUTPUT);
  pinMode(GLED, OUTPUT);
  pinMode(BLED, OUTPUT);
  
  
  SPI.begin();      // Init SPI bus
  rfid.PCD_Init();  // Init MFRC522
  myservo.attach(servoPin);
  myservo.write(0);

  for (byte i = 0; i < 6; i++) {
    key.keyByte[i] = 0xFF;
  }
  

  // Defined in thingProperties.h
  initProperties();
  
  Serial.println("Here!");

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maxim  um is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  
  Serial.println("Setup Complete");
}

void loop() {
  ArduinoCloud.update();
  // Your code here 
  
  //Serial.println(lightSensor());
  
  RFID();
  
  temperatureSensor = Celcius;
  
  ClimateControl(Desired);
  Lights(Current);
  
  setHomeStatusMsg();
  

  
  delay(1);
  
}



/*
  Since MatthiasAccess is READ_WRITE variable, onMatthiasAccessChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onMatthiasAccessChange()  {
  // Add your code here to act upon MatthiasAccess change
  
  Matthias.access =  matthiasAccess;
  
}

/*
  Since LukasAccess is READ_WRITE variable, onLukasAccessChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLukasAccessChange()  {
  // Add your code here to act upon LukasAccess change
  
  Lukas.access = lukasAccess;
}


